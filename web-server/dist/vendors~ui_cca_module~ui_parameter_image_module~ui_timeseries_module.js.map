{"version":3,"sources":["webpack:///./node_modules/babel-runtime/helpers/toConsumableArray.js","webpack:///./node_modules/papaparse/papaparse.js","webpack:///./node_modules/babel-runtime/core-js/array/from.js","webpack:///./node_modules/core-js/library/fn/array/from.js","webpack:///./node_modules/core-js/library/modules/es6.array.from.js","webpack:///./node_modules/core-js/library/modules/_create-property.js"],"names":["exports","__esModule","_from2","obj","default","_interopRequireDefault","__webpack_require__","arr","Array","isArray","i","arr2","length","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","AUTO_SCRIPT_PATH","global","self","window","IS_WORKER","document","postMessage","IS_PAPA_WORKER","test","location","search","LOADED_SYNC","workers","workerIdCounter","Papa","parse","_input","_config","dynamicTyping","isFunction","dynamicTypingFunction","worker","WORKERS_SUPPORTED","w","SCRIPT_PATH","Error","workerUrl","indexOf","Worker","onmessage","mainThreadReceivedMessage","id","newWorker","userStep","step","userChunk","chunk","userComplete","complete","userError","error","input","config","workerId","streamer","download","NetworkStreamer","StringStreamer","readable","read","on","ReadableStreamStreamer","File","Object","FileStreamer","stream","unparse","_quotes","_writeHeader","_delimiter","_newline","_quoteChar","delimiter","BAD_DELIMITERS","quotes","newline","quoteChar","header","quoteCharRegex","RegExp","JSON","serialize","objectKeys","data","fields","meta","keys","key","push","csv","hasHeader","dataKeyedByField","safe","row","maxCol","col","colIdx","str","toString","replace","needsQuotes","substrings","hasAny","charAt","RECORD_SEP","String","fromCharCode","UNIT_SEP","BYTE_ORDER_MARK","LocalChunkSize","RemoteChunkSize","DefaultDelimiter","Parser","ParserHandle","jQuery","$","fn","options","queue","this","each","idx","supported","prop","toUpperCase","attr","toLowerCase","FileReader","files","file","inputElem","instanceConfig","extend","parseNextFile","f","before","returned","action","name","elem","reason","fileComplete","userCompleteFunc","results","splice","ChunkStreamer","_handle","_paused","_finished","_baseIndex","_partialLine","_rowCount","_start","_nextChunk","isFirstChunk","_completeResults","errors","configCopy","copy","chunkSize","parseInt","call","parseChunk","beforeFirstChunk","modifiedChunk","aggregate","paused","aborted","lastIndex","cursor","substring","finishedIncludingPreview","preview","WORKER_ID","finished","concat","_sendError","xhr","_readChunk","_chunkLoaded","url","XMLHttpRequest","withCredentials","onload","bindFunction","onerror","_chunkError","open","downloadRequestHeaders","headers","headerName","setRequestHeader","end","send","err","message","status","readyState","contentRange","getResponseHeader","substr","lastIndexOf","getFileSize","responseText","errorMessage","errorText","statusText","reader","slice","usingAsyncReader","webkitSlice","mozSlice","FileReaderSync","Math","min","size","txt","readAsText","encoding","target","result","event","remaining","s","parseOnData","_streamData","_streamEnd","_streamError","shift","_streamCleanUp","removeListener","_parser","_delimiterError","FLOAT","_stepCounter","_aborted","_fields","_results","needsHeaderRow","processResults","abort","addError","skipEmptyLines","j","fillHeaderFields","field","value","parseDynamic","applyHeaderAndDynamicTyping","shouldApplyDynamicTyping","val","parseFloat","tryParseFloat","type","code","msg","baseIndex","ignoreLastRow","r","split","n","nAppearsFirst","numWithN","guessLineEndings","delimGuess","bestDelim","bestDelta","fieldCountPrevRow","delimChoices","delim","delta","avgFieldCount","fieldCount","abs","successful","bestDelimiter","guessDelimiter","parserConfig","pause","getCharIndex","resume","comments","fastMode","inputLen","delimLen","newlineLen","commentsLen","stepIsFunction","lastCursor","returnable","rows","pushRow","doStep","nextDelim","nextNewline","saveRow","quoteSearch","index","finish","newCursor","stopped","linebreak","truncated","e","handle","completeWorker","notImplemented","terminate","cpy","apply","arguments","func","scripts","getElementsByTagName","src","getScriptPath","body","addEventListener","prototype","create","constructor","module","from","ctx","$export","toObject","isArrayIter","toLength","createProperty","getIterFn","S","F","iter","arrayLike","iterator","O","C","aLen","mapfn","mapping","iterFn","next","done","$defineProperty","createDesc","object"],"mappings":"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","file":"vendors~ui_cca_module~ui_parameter_image_module~ui_timeseries_module.js","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\n\nvar _from = require(\"../core-js/array/from\");\n\nvar _from2 = _interopRequireDefault(_from);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return (0, _from2.default)(arr);\n  }\n};","/*!\n\tPapa Parse\n\tv4.3.2\n\thttps://github.com/mholt/PapaParse\n*/\n(function(root, factory)\n{\n\tif (typeof define === 'function' && define.amd)\n\t{\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([], factory);\n\t}\n\telse if (typeof module === 'object' && module.exports)\n\t{\n\t\t// Node. Does not work with strict CommonJS, but\n\t\t// only CommonJS-like environments that support module.exports,\n\t\t// like Node.\n\t\tmodule.exports = factory();\n\t}\n\telse\n\t{\n\t\t// Browser globals (root is window)\n\t\troot.Papa = factory();\n\t}\n}(this, function()\n{\n\t'use strict';\n\n\tvar global = (function () {\n\t\t// alternative method, similar to `Function('return this')()`\n\t\t// but without using `eval` (which is disabled when\n\t\t// using Content Security Policy).\n\n\t\tif (typeof self !== 'undefined') { return self; }\n\t\tif (typeof window !== 'undefined') { return window; }\n\t\tif (typeof global !== 'undefined') { return global; }\n\n        // When running tests none of the above have been defined\n        return {};\n\t})();\n\n\n\tvar IS_WORKER = !global.document && !!global.postMessage,\n\t\tIS_PAPA_WORKER = IS_WORKER && /(\\?|&)papaworker(=|&|$)/.test(global.location.search),\n\t\tLOADED_SYNC = false, AUTO_SCRIPT_PATH;\n\tvar workers = {}, workerIdCounter = 0;\n\n\tvar Papa = {};\n\n\tPapa.parse = CsvToJson;\n\tPapa.unparse = JsonToCsv;\n\n\tPapa.RECORD_SEP = String.fromCharCode(30);\n\tPapa.UNIT_SEP = String.fromCharCode(31);\n\tPapa.BYTE_ORDER_MARK = '\\ufeff';\n\tPapa.BAD_DELIMITERS = ['\\r', '\\n', '\"', Papa.BYTE_ORDER_MARK];\n\tPapa.WORKERS_SUPPORTED = !IS_WORKER && !!global.Worker;\n\tPapa.SCRIPT_PATH = null;\t// Must be set by your code if you use workers and this lib is loaded asynchronously\n\n\t// Configurable chunk sizes for local and remote files, respectively\n\tPapa.LocalChunkSize = 1024 * 1024 * 10;\t// 10 MB\n\tPapa.RemoteChunkSize = 1024 * 1024 * 5;\t// 5 MB\n\tPapa.DefaultDelimiter = ',';\t\t\t// Used if not specified and detection fails\n\n\t// Exposed for testing and development only\n\tPapa.Parser = Parser;\n\tPapa.ParserHandle = ParserHandle;\n\tPapa.NetworkStreamer = NetworkStreamer;\n\tPapa.FileStreamer = FileStreamer;\n\tPapa.StringStreamer = StringStreamer;\n\tPapa.ReadableStreamStreamer = ReadableStreamStreamer;\n\n\tif (global.jQuery)\n\t{\n\t\tvar $ = global.jQuery;\n\t\t$.fn.parse = function(options)\n\t\t{\n\t\t\tvar config = options.config || {};\n\t\t\tvar queue = [];\n\n\t\t\tthis.each(function(idx)\n\t\t\t{\n\t\t\t\tvar supported = $(this).prop('tagName').toUpperCase() === 'INPUT'\n\t\t\t\t\t\t\t\t&& $(this).attr('type').toLowerCase() === 'file'\n\t\t\t\t\t\t\t\t&& global.FileReader;\n\n\t\t\t\tif (!supported || !this.files || this.files.length === 0)\n\t\t\t\t\treturn true;\t// continue to next input element\n\n\t\t\t\tfor (var i = 0; i < this.files.length; i++)\n\t\t\t\t{\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\tfile: this.files[i],\n\t\t\t\t\t\tinputElem: this,\n\t\t\t\t\t\tinstanceConfig: $.extend({}, config)\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tparseNextFile();\t// begin parsing\n\t\t\treturn this;\t\t// maintains chainability\n\n\n\t\t\tfunction parseNextFile()\n\t\t\t{\n\t\t\t\tif (queue.length === 0)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(options.complete))\n\t\t\t\t\t\toptions.complete();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar f = queue[0];\n\n\t\t\t\tif (isFunction(options.before))\n\t\t\t\t{\n\t\t\t\t\tvar returned = options.before(f.file, f.inputElem);\n\n\t\t\t\t\tif (typeof returned === 'object')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (returned.action === 'abort')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\terror('AbortError', f.file, f.inputElem, returned.reason);\n\t\t\t\t\t\t\treturn;\t// Aborts all queued files immediately\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (returned.action === 'skip')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (typeof returned.config === 'object')\n\t\t\t\t\t\t\tf.instanceConfig = $.extend(f.instanceConfig, returned.config);\n\t\t\t\t\t}\n\t\t\t\t\telse if (returned === 'skip')\n\t\t\t\t\t{\n\t\t\t\t\t\tfileComplete();\t// parse the next file in the queue, if any\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Wrap up the user's complete callback, if any, so that ours also gets executed\n\t\t\t\tvar userCompleteFunc = f.instanceConfig.complete;\n\t\t\t\tf.instanceConfig.complete = function(results)\n\t\t\t\t{\n\t\t\t\t\tif (isFunction(userCompleteFunc))\n\t\t\t\t\t\tuserCompleteFunc(results, f.file, f.inputElem);\n\t\t\t\t\tfileComplete();\n\t\t\t\t};\n\n\t\t\t\tPapa.parse(f.file, f.instanceConfig);\n\t\t\t}\n\n\t\t\tfunction error(name, file, elem, reason)\n\t\t\t{\n\t\t\t\tif (isFunction(options.error))\n\t\t\t\t\toptions.error({name: name}, file, elem, reason);\n\t\t\t}\n\n\t\t\tfunction fileComplete()\n\t\t\t{\n\t\t\t\tqueue.splice(0, 1);\n\t\t\t\tparseNextFile();\n\t\t\t}\n\t\t}\n\t}\n\n\n\tif (IS_PAPA_WORKER)\n\t{\n\t\tglobal.onmessage = workerThreadReceivedMessage;\n\t}\n\telse if (Papa.WORKERS_SUPPORTED)\n\t{\n\t\tAUTO_SCRIPT_PATH = getScriptPath();\n\n\t\t// Check if the script was loaded synchronously\n\t\tif (!document.body)\n\t\t{\n\t\t\t// Body doesn't exist yet, must be synchronous\n\t\t\tLOADED_SYNC = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdocument.addEventListener('DOMContentLoaded', function () {\n\t\t\t\tLOADED_SYNC = true;\n\t\t\t}, true);\n\t\t}\n\t}\n\n\n\n\n\tfunction CsvToJson(_input, _config)\n\t{\n\t\t_config = _config || {};\n        var dynamicTyping = _config.dynamicTyping || false;\n        if (isFunction(dynamicTyping)) {\n            _config.dynamicTypingFunction = dynamicTyping;\n            // Will be filled on first row call\n            dynamicTyping = {};\n        }\n        _config.dynamicTyping = dynamicTyping;\n\n\t\tif (_config.worker && Papa.WORKERS_SUPPORTED)\n\t\t{\n\t\t\tvar w = newWorker();\n\n\t\t\tw.userStep = _config.step;\n\t\t\tw.userChunk = _config.chunk;\n\t\t\tw.userComplete = _config.complete;\n\t\t\tw.userError = _config.error;\n\n\t\t\t_config.step = isFunction(_config.step);\n\t\t\t_config.chunk = isFunction(_config.chunk);\n\t\t\t_config.complete = isFunction(_config.complete);\n\t\t\t_config.error = isFunction(_config.error);\n\t\t\tdelete _config.worker;\t// prevent infinite loop\n\n\t\t\tw.postMessage({\n\t\t\t\tinput: _input,\n\t\t\t\tconfig: _config,\n\t\t\t\tworkerId: w.id\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\tvar streamer = null;\n\t\tif (typeof _input === 'string')\n\t\t{\n\t\t\tif (_config.download)\n\t\t\t\tstreamer = new NetworkStreamer(_config);\n\t\t\telse\n\t\t\t\tstreamer = new StringStreamer(_config);\n\t\t}\n\t\telse if (_input.readable === true && isFunction(_input.read) && isFunction(_input.on))\n\t\t{\n\t\t\tstreamer = new ReadableStreamStreamer(_config);\n\t\t}\n\t\telse if ((global.File && _input instanceof File) || _input instanceof Object)\t// ...Safari. (see issue #106)\n\t\t\tstreamer = new FileStreamer(_config);\n\n\t\treturn streamer.stream(_input);\n\t}\n\n\n\n\n\n\n\tfunction JsonToCsv(_input, _config)\n\t{\n\t\tvar _output = '';\n\t\tvar _fields = [];\n\n\t\t// Default configuration\n\n\t\t/** whether to surround every datum with quotes */\n\t\tvar _quotes = false;\n\n\t\t/** whether to write headers */\n\t\tvar _writeHeader = true;\n\n\t\t/** delimiting character */\n\t\tvar _delimiter = ',';\n\n\t\t/** newline character(s) */\n\t\tvar _newline = '\\r\\n';\n\n\t\t/** quote character */\n\t\tvar _quoteChar = '\"';\n\n\t\tunpackConfig();\n\n\t\tvar quoteCharRegex = new RegExp(_quoteChar, 'g');\n\n\t\tif (typeof _input === 'string')\n\t\t\t_input = JSON.parse(_input);\n\n\t\tif (_input instanceof Array)\n\t\t{\n\t\t\tif (!_input.length || _input[0] instanceof Array)\n\t\t\t\treturn serialize(null, _input);\n\t\t\telse if (typeof _input[0] === 'object')\n\t\t\t\treturn serialize(objectKeys(_input[0]), _input);\n\t\t}\n\t\telse if (typeof _input === 'object')\n\t\t{\n\t\t\tif (typeof _input.data === 'string')\n\t\t\t\t_input.data = JSON.parse(_input.data);\n\n\t\t\tif (_input.data instanceof Array)\n\t\t\t{\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields =  _input.meta && _input.meta.fields;\n\n\t\t\t\tif (!_input.fields)\n\t\t\t\t\t_input.fields =  _input.data[0] instanceof Array\n\t\t\t\t\t\t\t\t\t? _input.fields\n\t\t\t\t\t\t\t\t\t: objectKeys(_input.data[0]);\n\n\t\t\t\tif (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')\n\t\t\t\t\t_input.data = [_input.data];\t// handles input like [1,2,3] or ['asdf']\n\t\t\t}\n\n\t\t\treturn serialize(_input.fields || [], _input.data || []);\n\t\t}\n\n\t\t// Default (any valid paths should return before this)\n\t\tthrow 'exception: Unable to serialize unrecognized input';\n\n\n\t\tfunction unpackConfig()\n\t\t{\n\t\t\tif (typeof _config !== 'object')\n\t\t\t\treturn;\n\n\t\t\tif (typeof _config.delimiter === 'string'\n\t\t\t\t&& _config.delimiter.length === 1\n\t\t\t\t&& Papa.BAD_DELIMITERS.indexOf(_config.delimiter) === -1)\n\t\t\t{\n\t\t\t\t_delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tif (typeof _config.quotes === 'boolean'\n\t\t\t\t|| _config.quotes instanceof Array)\n\t\t\t\t_quotes = _config.quotes;\n\n\t\t\tif (typeof _config.newline === 'string')\n\t\t\t\t_newline = _config.newline;\n\n\t\t\tif (typeof _config.quoteChar === 'string')\n\t\t\t\t_quoteChar = _config.quoteChar;\n\n\t\t\tif (typeof _config.header === 'boolean')\n\t\t\t\t_writeHeader = _config.header;\n\t\t}\n\n\n\t\t/** Turns an object's keys into an array */\n\t\tfunction objectKeys(obj)\n\t\t{\n\t\t\tif (typeof obj !== 'object')\n\t\t\t\treturn [];\n\t\t\tvar keys = [];\n\t\t\tfor (var key in obj)\n\t\t\t\tkeys.push(key);\n\t\t\treturn keys;\n\t\t}\n\n\t\t/** The double for loop that iterates the data and writes out a CSV string including header row */\n\t\tfunction serialize(fields, data)\n\t\t{\n\t\t\tvar csv = '';\n\n\t\t\tif (typeof fields === 'string')\n\t\t\t\tfields = JSON.parse(fields);\n\t\t\tif (typeof data === 'string')\n\t\t\t\tdata = JSON.parse(data);\n\n\t\t\tvar hasHeader = fields instanceof Array && fields.length > 0;\n\t\t\tvar dataKeyedByField = !(data[0] instanceof Array);\n\n\t\t\t// If there a header row, write it first\n\t\t\tif (hasHeader && _writeHeader)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < fields.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\tcsv += safe(fields[i], i);\n\t\t\t\t}\n\t\t\t\tif (data.length > 0)\n\t\t\t\t\tcsv += _newline;\n\t\t\t}\n\n\t\t\t// Then write out the data\n\t\t\tfor (var row = 0; row < data.length; row++)\n\t\t\t{\n\t\t\t\tvar maxCol = hasHeader ? fields.length : data[row].length;\n\n\t\t\t\tfor (var col = 0; col < maxCol; col++)\n\t\t\t\t{\n\t\t\t\t\tif (col > 0)\n\t\t\t\t\t\tcsv += _delimiter;\n\t\t\t\t\tvar colIdx = hasHeader && dataKeyedByField ? fields[col] : col;\n\t\t\t\t\tcsv += safe(data[row][colIdx], col);\n\t\t\t\t}\n\n\t\t\t\tif (row < data.length - 1)\n\t\t\t\t\tcsv += _newline;\n\t\t\t}\n\n\t\t\treturn csv;\n\t\t}\n\n\t\t/** Encloses a value around quotes if needed (makes a value safe for CSV insertion) */\n\t\tfunction safe(str, col)\n\t\t{\n\t\t\tif (typeof str === 'undefined' || str === null)\n\t\t\t\treturn '';\n\n\t\t\tstr = str.toString().replace(quoteCharRegex, _quoteChar+_quoteChar);\n\n\t\t\tvar needsQuotes = (typeof _quotes === 'boolean' && _quotes)\n\t\t\t\t\t\t\t|| (_quotes instanceof Array && _quotes[col])\n\t\t\t\t\t\t\t|| hasAny(str, Papa.BAD_DELIMITERS)\n\t\t\t\t\t\t\t|| str.indexOf(_delimiter) > -1\n\t\t\t\t\t\t\t|| str.charAt(0) === ' '\n\t\t\t\t\t\t\t|| str.charAt(str.length - 1) === ' ';\n\n\t\t\treturn needsQuotes ? _quoteChar + str + _quoteChar : str;\n\t\t}\n\n\t\tfunction hasAny(str, substrings)\n\t\t{\n\t\t\tfor (var i = 0; i < substrings.length; i++)\n\t\t\t\tif (str.indexOf(substrings[i]) > -1)\n\t\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/** ChunkStreamer is the base prototype for various streamer implementations. */\n\tfunction ChunkStreamer(config)\n\t{\n\t\tthis._handle = null;\n\t\tthis._paused = false;\n\t\tthis._finished = false;\n\t\tthis._input = null;\n\t\tthis._baseIndex = 0;\n\t\tthis._partialLine = '';\n\t\tthis._rowCount = 0;\n\t\tthis._start = 0;\n\t\tthis._nextChunk = null;\n\t\tthis.isFirstChunk = true;\n\t\tthis._completeResults = {\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\t\treplaceConfig.call(this, config);\n\n\t\tthis.parseChunk = function(chunk)\n\t\t{\n\t\t\t// First chunk pre-processing\n\t\t\tif (this.isFirstChunk && isFunction(this._config.beforeFirstChunk))\n\t\t\t{\n\t\t\t\tvar modifiedChunk = this._config.beforeFirstChunk(chunk);\n\t\t\t\tif (modifiedChunk !== undefined)\n\t\t\t\t\tchunk = modifiedChunk;\n\t\t\t}\n\t\t\tthis.isFirstChunk = false;\n\n\t\t\t// Rejoin the line we likely just split in two by chunking the file\n\t\t\tvar aggregate = this._partialLine + chunk;\n\t\t\tthis._partialLine = '';\n\n\t\t\tvar results = this._handle.parse(aggregate, this._baseIndex, !this._finished);\n\n\t\t\tif (this._handle.paused() || this._handle.aborted())\n\t\t\t\treturn;\n\n\t\t\tvar lastIndex = results.meta.cursor;\n\n\t\t\tif (!this._finished)\n\t\t\t{\n\t\t\t\tthis._partialLine = aggregate.substring(lastIndex - this._baseIndex);\n\t\t\t\tthis._baseIndex = lastIndex;\n\t\t\t}\n\n\t\t\tif (results && results.data)\n\t\t\t\tthis._rowCount += results.data.length;\n\n\t\t\tvar finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);\n\n\t\t\tif (IS_PAPA_WORKER)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tresults: results,\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tfinished: finishedIncludingPreview\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if (isFunction(this._config.chunk))\n\t\t\t{\n\t\t\t\tthis._config.chunk(results, this._handle);\n\t\t\t\tif (this._paused)\n\t\t\t\t\treturn;\n\t\t\t\tresults = undefined;\n\t\t\t\tthis._completeResults = undefined;\n\t\t\t}\n\n\t\t\tif (!this._config.step && !this._config.chunk) {\n\t\t\t\tthis._completeResults.data = this._completeResults.data.concat(results.data);\n\t\t\t\tthis._completeResults.errors = this._completeResults.errors.concat(results.errors);\n\t\t\t\tthis._completeResults.meta = results.meta;\n\t\t\t}\n\n\t\t\tif (finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted))\n\t\t\t\tthis._config.complete(this._completeResults, this._input);\n\n\t\t\tif (!finishedIncludingPreview && (!results || !results.meta.paused))\n\t\t\t\tthis._nextChunk();\n\n\t\t\treturn results;\n\t\t};\n\n\t\tthis._sendError = function(error)\n\t\t{\n\t\t\tif (isFunction(this._config.error))\n\t\t\t\tthis._config.error(error);\n\t\t\telse if (IS_PAPA_WORKER && this._config.error)\n\t\t\t{\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\terror: error,\n\t\t\t\t\tfinished: false\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tfunction replaceConfig(config)\n\t\t{\n\t\t\t// Deep-copy the config so we can edit it\n\t\t\tvar configCopy = copy(config);\n\t\t\tconfigCopy.chunkSize = parseInt(configCopy.chunkSize);\t// parseInt VERY important so we don't concatenate strings!\n\t\t\tif (!config.step && !config.chunk)\n\t\t\t\tconfigCopy.chunkSize = null;  // disable Range header if not streaming; bad values break IIS - see issue #196\n\t\t\tthis._handle = new ParserHandle(configCopy);\n\t\t\tthis._handle.streamer = this;\n\t\t\tthis._config = configCopy;\t// persist the copy to the caller\n\t\t}\n\t}\n\n\n\tfunction NetworkStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.RemoteChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar xhr;\n\n\t\tif (IS_WORKER)\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t\tthis._chunkLoaded();\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._nextChunk = function()\n\t\t\t{\n\t\t\t\tthis._readChunk();\n\t\t\t};\n\t\t}\n\n\t\tthis.stream = function(url)\n\t\t{\n\t\t\tthis._input = url;\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tif (this._finished)\n\t\t\t{\n\t\t\t\tthis._chunkLoaded();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\txhr = new XMLHttpRequest();\n\n\t\t\tif (this._config.withCredentials)\n\t\t\t{\n\t\t\t\txhr.withCredentials = this._config.withCredentials;\n\t\t\t}\n\n\t\t\tif (!IS_WORKER)\n\t\t\t{\n\t\t\t\txhr.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\txhr.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\n\t\t\txhr.open('GET', this._input, !IS_WORKER);\n\t\t\t// Headers can only be set when once the request state is OPENED\n\t\t\tif (this._config.downloadRequestHeaders)\n\t\t\t{\n\t\t\t\tvar headers = this._config.downloadRequestHeaders;\n\n\t\t\t\tfor (var headerName in headers)\n\t\t\t\t{\n\t\t\t\t\txhr.setRequestHeader(headerName, headers[headerName]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = this._start + this._config.chunkSize - 1;\t// minus one because byte range is inclusive\n\t\t\t\txhr.setRequestHeader('Range', 'bytes='+this._start+'-'+end);\n\t\t\t\txhr.setRequestHeader('If-None-Match', 'webkit-no-cache'); // https://bugs.webkit.org/show_bug.cgi?id=82672\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\txhr.send();\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\tthis._chunkError(err.message);\n\t\t\t}\n\n\t\t\tif (IS_WORKER && xhr.status === 0)\n\t\t\t\tthis._chunkError();\n\t\t\telse\n\t\t\t\tthis._start += this._config.chunkSize;\n\t\t}\n\n\t\tthis._chunkLoaded = function()\n\t\t{\n\t\t\tif (xhr.readyState != 4)\n\t\t\t\treturn;\n\n\t\t\tif (xhr.status < 200 || xhr.status >= 400)\n\t\t\t{\n\t\t\t\tthis._chunkError();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._finished = !this._config.chunkSize || this._start > getFileSize(xhr);\n\t\t\tthis.parseChunk(xhr.responseText);\n\t\t}\n\n\t\tthis._chunkError = function(errorMessage)\n\t\t{\n\t\t\tvar errorText = xhr.statusText || errorMessage;\n\t\t\tthis._sendError(errorText);\n\t\t}\n\n\t\tfunction getFileSize(xhr)\n\t\t{\n\t\t\tvar contentRange = xhr.getResponseHeader('Content-Range');\n\t\t\tif (contentRange === null) { // no content range, then finish!\n        \t\t\treturn -1;\n            \t\t}\n\t\t\treturn parseInt(contentRange.substr(contentRange.lastIndexOf('/') + 1));\n\t\t}\n\t}\n\tNetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tNetworkStreamer.prototype.constructor = NetworkStreamer;\n\n\n\tfunction FileStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tif (!config.chunkSize)\n\t\t\tconfig.chunkSize = Papa.LocalChunkSize;\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar reader, slice;\n\n\t\t// FileReader is better than FileReaderSync (even in worker) - see http://stackoverflow.com/q/24708649/1048862\n\t\t// But Firefox is a pill, too - see issue #76: https://github.com/mholt/PapaParse/issues/76\n\t\tvar usingAsyncReader = typeof FileReader !== 'undefined';\t// Safari doesn't consider it a function - see issue #105\n\n\t\tthis.stream = function(file)\n\t\t{\n\t\t\tthis._input = file;\n\t\t\tslice = file.slice || file.webkitSlice || file.mozSlice;\n\n\t\t\tif (usingAsyncReader)\n\t\t\t{\n\t\t\t\treader = new FileReader();\t\t// Preferred method of reading files, even in workers\n\t\t\t\treader.onload = bindFunction(this._chunkLoaded, this);\n\t\t\t\treader.onerror = bindFunction(this._chunkError, this);\n\t\t\t}\n\t\t\telse\n\t\t\t\treader = new FileReaderSync();\t// Hack for running in a web worker in Firefox\n\n\t\t\tthis._nextChunk();\t// Starts streaming\n\t\t};\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))\n\t\t\t\tthis._readChunk();\n\t\t}\n\n\t\tthis._readChunk = function()\n\t\t{\n\t\t\tvar input = this._input;\n\t\t\tif (this._config.chunkSize)\n\t\t\t{\n\t\t\t\tvar end = Math.min(this._start + this._config.chunkSize, this._input.size);\n\t\t\t\tinput = slice.call(input, this._start, end);\n\t\t\t}\n\t\t\tvar txt = reader.readAsText(input, this._config.encoding);\n\t\t\tif (!usingAsyncReader)\n\t\t\t\tthis._chunkLoaded({ target: { result: txt } });\t// mimic the async signature\n\t\t}\n\n\t\tthis._chunkLoaded = function(event)\n\t\t{\n\t\t\t// Very important to increment start each time before handling results\n\t\t\tthis._start += this._config.chunkSize;\n\t\t\tthis._finished = !this._config.chunkSize || this._start >= this._input.size;\n\t\t\tthis.parseChunk(event.target.result);\n\t\t}\n\n\t\tthis._chunkError = function()\n\t\t{\n\t\t\tthis._sendError(reader.error);\n\t\t}\n\n\t}\n\tFileStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tFileStreamer.prototype.constructor = FileStreamer;\n\n\n\tfunction StringStreamer(config)\n\t{\n\t\tconfig = config || {};\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar string;\n\t\tvar remaining;\n\t\tthis.stream = function(s)\n\t\t{\n\t\t\tstring = s;\n\t\t\tremaining = s;\n\t\t\treturn this._nextChunk();\n\t\t}\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (this._finished) return;\n\t\t\tvar size = this._config.chunkSize;\n\t\t\tvar chunk = size ? remaining.substr(0, size) : remaining;\n\t\t\tremaining = size ? remaining.substr(size) : '';\n\t\t\tthis._finished = !remaining;\n\t\t\treturn this.parseChunk(chunk);\n\t\t}\n\t}\n\tStringStreamer.prototype = Object.create(StringStreamer.prototype);\n\tStringStreamer.prototype.constructor = StringStreamer;\n\n\n\tfunction ReadableStreamStreamer(config)\n\t{\n\t\tconfig = config || {};\n\n\t\tChunkStreamer.call(this, config);\n\n\t\tvar queue = [];\n\t\tvar parseOnData = true;\n\n\t\tthis.stream = function(stream)\n\t\t{\n\t\t\tthis._input = stream;\n\n\t\t\tthis._input.on('data', this._streamData);\n\t\t\tthis._input.on('end', this._streamEnd);\n\t\t\tthis._input.on('error', this._streamError);\n\t\t}\n\n\t\tthis._nextChunk = function()\n\t\t{\n\t\t\tif (queue.length)\n\t\t\t{\n\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tparseOnData = true;\n\t\t\t}\n\t\t}\n\n\t\tthis._streamData = bindFunction(function(chunk)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tqueue.push(typeof chunk === 'string' ? chunk : chunk.toString(this._config.encoding));\n\n\t\t\t\tif (parseOnData)\n\t\t\t\t{\n\t\t\t\t\tparseOnData = false;\n\t\t\t\t\tthis.parseChunk(queue.shift());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (error)\n\t\t\t{\n\t\t\t\tthis._streamError(error);\n\t\t\t}\n\t\t}, this);\n\n\t\tthis._streamError = bindFunction(function(error)\n\t\t{\n\t\t\tthis._streamCleanUp();\n\t\t\tthis._sendError(error.message);\n\t\t}, this);\n\n\t\tthis._streamEnd = bindFunction(function()\n\t\t{\n\t\t\tthis._streamCleanUp();\n\t\t\tthis._finished = true;\n\t\t\tthis._streamData('');\n\t\t}, this);\n\n\t\tthis._streamCleanUp = bindFunction(function()\n\t\t{\n\t\t\tthis._input.removeListener('data', this._streamData);\n\t\t\tthis._input.removeListener('end', this._streamEnd);\n\t\t\tthis._input.removeListener('error', this._streamError);\n\t\t}, this);\n\t}\n\tReadableStreamStreamer.prototype = Object.create(ChunkStreamer.prototype);\n\tReadableStreamStreamer.prototype.constructor = ReadableStreamStreamer;\n\n\n\t// Use one ParserHandle per entire CSV file or string\n\tfunction ParserHandle(_config)\n\t{\n\t\t// One goal is to minimize the use of regular expressions...\n\t\tvar FLOAT = /^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i;\n\n\t\tvar self = this;\n\t\tvar _stepCounter = 0;\t// Number of times step was called (number of rows parsed)\n\t\tvar _input;\t\t\t\t// The input being parsed\n\t\tvar _parser;\t\t\t// The core parser being used\n\t\tvar _paused = false;\t// Whether we are paused or not\n\t\tvar _aborted = false;   // Whether the parser has aborted or not\n\t\tvar _delimiterError;\t// Temporary state between delimiter detection and processing results\n\t\tvar _fields = [];\t\t// Fields are from the header row of the input, if there is one\n\t\tvar _results = {\t\t// The last results returned from the parser\n\t\t\tdata: [],\n\t\t\terrors: [],\n\t\t\tmeta: {}\n\t\t};\n\n\t\tif (isFunction(_config.step))\n\t\t{\n\t\t\tvar userStep = _config.step;\n\t\t\t_config.step = function(results)\n\t\t\t{\n\t\t\t\t_results = results;\n\n\t\t\t\tif (needsHeaderRow())\n\t\t\t\t\tprocessResults();\n\t\t\t\telse\t// only call user's step function after header row\n\t\t\t\t{\n\t\t\t\t\tprocessResults();\n\n\t\t\t\t\t// It's possbile that this line was empty and there's no row here after all\n\t\t\t\t\tif (_results.data.length === 0)\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t_stepCounter += results.data.length;\n\t\t\t\t\tif (_config.preview && _stepCounter > _config.preview)\n\t\t\t\t\t\t_parser.abort();\n\t\t\t\t\telse\n\t\t\t\t\t\tuserStep(_results, self);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Parses input. Most users won't need, and shouldn't mess with, the baseIndex\n\t\t * and ignoreLastRow parameters. They are used by streamers (wrapper functions)\n\t\t * when an input comes in multiple chunks, like from a file.\n\t\t */\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\tif (!_config.newline)\n\t\t\t\t_config.newline = guessLineEndings(input);\n\n\t\t\t_delimiterError = false;\n\t\t\tif (!_config.delimiter)\n\t\t\t{\n\t\t\t\tvar delimGuess = guessDelimiter(input, _config.newline);\n\t\t\t\tif (delimGuess.successful)\n\t\t\t\t\t_config.delimiter = delimGuess.bestDelimiter;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t_delimiterError = true;\t// add error after parsing (otherwise it would be overwritten)\n\t\t\t\t\t_config.delimiter = Papa.DefaultDelimiter;\n\t\t\t\t}\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\t\t\telse if(isFunction(_config.delimiter))\n\t\t\t{\n\t\t\t\t_config.delimiter = _config.delimiter(input);\n\t\t\t\t_results.meta.delimiter = _config.delimiter;\n\t\t\t}\n\n\t\t\tvar parserConfig = copy(_config);\n\t\t\tif (_config.preview && _config.header)\n\t\t\t\tparserConfig.preview++;\t// to compensate for header row\n\n\t\t\t_input = input;\n\t\t\t_parser = new Parser(parserConfig);\n\t\t\t_results = _parser.parse(_input, baseIndex, ignoreLastRow);\n\t\t\tprocessResults();\n\t\t\treturn _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });\n\t\t};\n\n\t\tthis.paused = function()\n\t\t{\n\t\t\treturn _paused;\n\t\t};\n\n\t\tthis.pause = function()\n\t\t{\n\t\t\t_paused = true;\n\t\t\t_parser.abort();\n\t\t\t_input = _input.substr(_parser.getCharIndex());\n\t\t};\n\n\t\tthis.resume = function()\n\t\t{\n\t\t\t_paused = false;\n\t\t\tself.streamer.parseChunk(_input);\n\t\t};\n\n\t\tthis.aborted = function ()\n\t\t{\n\t\t\treturn _aborted;\n\t\t};\n\n\t\tthis.abort = function()\n\t\t{\n\t\t\t_aborted = true;\n\t\t\t_parser.abort();\n\t\t\t_results.meta.aborted = true;\n\t\t\tif (isFunction(_config.complete))\n\t\t\t\t_config.complete(_results);\n\t\t\t_input = '';\n\t\t};\n\n\t\tfunction processResults()\n\t\t{\n\t\t\tif (_results && _delimiterError)\n\t\t\t{\n\t\t\t\taddError('Delimiter', 'UndetectableDelimiter', 'Unable to auto-detect delimiting character; defaulted to \\''+Papa.DefaultDelimiter+'\\'');\n\t\t\t\t_delimiterError = false;\n\t\t\t}\n\n\t\t\tif (_config.skipEmptyLines)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t\t\tif (_results.data[i].length === 1 && _results.data[i][0] === '')\n\t\t\t\t\t\t_results.data.splice(i--, 1);\n\t\t\t}\n\n\t\t\tif (needsHeaderRow())\n\t\t\t\tfillHeaderFields();\n\n\t\t\treturn applyHeaderAndDynamicTyping();\n\t\t}\n\n\t\tfunction needsHeaderRow()\n\t\t{\n\t\t\treturn _config.header && _fields.length === 0;\n\t\t}\n\n\t\tfunction fillHeaderFields()\n\t\t{\n\t\t\tif (!_results)\n\t\t\t\treturn;\n\t\t\tfor (var i = 0; needsHeaderRow() && i < _results.data.length; i++)\n\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t\t_fields.push(_results.data[i][j]);\n\t\t\t_results.data.splice(0, 1);\n\t\t}\n\n        function shouldApplyDynamicTyping(field) {\n            // Cache function values to avoid calling it for each row\n            if (_config.dynamicTypingFunction && _config.dynamicTyping[field] === undefined) {\n                _config.dynamicTyping[field] = _config.dynamicTypingFunction(field);\n            }\n            return (_config.dynamicTyping[field] || _config.dynamicTyping) === true\n        }\n\n\t\tfunction parseDynamic(field, value)\n\t\t{\n\t\t\tif (shouldApplyDynamicTyping(field))\n\t\t\t{\n\t\t\t\tif (value === 'true' || value === 'TRUE')\n\t\t\t\t\treturn true;\n\t\t\t\telse if (value === 'false' || value === 'FALSE')\n\t\t\t\t\treturn false;\n\t\t\t\telse\n\t\t\t\t\treturn tryParseFloat(value);\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\n\t\tfunction applyHeaderAndDynamicTyping()\n\t\t{\n\t\t\tif (!_results || (!_config.header && !_config.dynamicTyping))\n\t\t\t\treturn _results;\n\n\t\t\tfor (var i = 0; i < _results.data.length; i++)\n\t\t\t{\n\t\t\t\tvar row = _config.header ? {} : [];\n\n\t\t\t\tfor (var j = 0; j < _results.data[i].length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar field = j;\n\t\t\t\t\tvar value = _results.data[i][j];\n\n\t\t\t\t\tif (_config.header)\n\t\t\t\t\t\tfield = j >= _fields.length ? '__parsed_extra' : _fields[j];\n\n\t\t\t\t\tvalue = parseDynamic(field, value);\n\n\t\t\t\t\tif (field === '__parsed_extra')\n\t\t\t\t\t{\n\t\t\t\t\t\trow[field] = row[field] || [];\n\t\t\t\t\t\trow[field].push(value);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\trow[field] = value;\n\t\t\t\t}\n\n\t\t\t\t_results.data[i] = row;\n\n\t\t\t\tif (_config.header)\n\t\t\t\t{\n\t\t\t\t\tif (j > _fields.length)\n\t\t\t\t\t\taddError('FieldMismatch', 'TooManyFields', 'Too many fields: expected ' + _fields.length + ' fields but parsed ' + j, i);\n\t\t\t\t\telse if (j < _fields.length)\n\t\t\t\t\t\taddError('FieldMismatch', 'TooFewFields', 'Too few fields: expected ' + _fields.length + ' fields but parsed ' + j, i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (_config.header && _results.meta)\n\t\t\t\t_results.meta.fields = _fields;\n\t\t\treturn _results;\n\t\t}\n\n\t\tfunction guessDelimiter(input, newline)\n\t\t{\n\t\t\tvar delimChoices = [',', '\\t', '|', ';', Papa.RECORD_SEP, Papa.UNIT_SEP];\n\t\t\tvar bestDelim, bestDelta, fieldCountPrevRow;\n\n\t\t\tfor (var i = 0; i < delimChoices.length; i++)\n\t\t\t{\n\t\t\t\tvar delim = delimChoices[i];\n\t\t\t\tvar delta = 0, avgFieldCount = 0;\n\t\t\t\tfieldCountPrevRow = undefined;\n\n\t\t\t\tvar preview = new Parser({\n\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\tnewline: newline,\n\t\t\t\t\tpreview: 10\n\t\t\t\t}).parse(input);\n\n\t\t\t\tfor (var j = 0; j < preview.data.length; j++)\n\t\t\t\t{\n\t\t\t\t\tvar fieldCount = preview.data[j].length;\n\t\t\t\t\tavgFieldCount += fieldCount;\n\n\t\t\t\t\tif (typeof fieldCountPrevRow === 'undefined')\n\t\t\t\t\t{\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if (fieldCount > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tdelta += Math.abs(fieldCount - fieldCountPrevRow);\n\t\t\t\t\t\tfieldCountPrevRow = fieldCount;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (preview.data.length > 0)\n\t\t\t\t\tavgFieldCount /= preview.data.length;\n\n\t\t\t\tif ((typeof bestDelta === 'undefined' || delta < bestDelta)\n\t\t\t\t\t&& avgFieldCount > 1.99)\n\t\t\t\t{\n\t\t\t\t\tbestDelta = delta;\n\t\t\t\t\tbestDelim = delim;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_config.delimiter = bestDelim;\n\n\t\t\treturn {\n\t\t\t\tsuccessful: !!bestDelim,\n\t\t\t\tbestDelimiter: bestDelim\n\t\t\t}\n\t\t}\n\n\t\tfunction guessLineEndings(input)\n\t\t{\n\t\t\tinput = input.substr(0, 1024*1024);\t// max length 1 MB\n\n\t\t\tvar r = input.split('\\r');\n\n\t\t\tvar n = input.split('\\n');\n\n\t\t\tvar nAppearsFirst = (n.length > 1 && n[0].length < r[0].length);\n\n\t\t\tif (r.length === 1 || nAppearsFirst)\n\t\t\t\treturn '\\n';\n\n\t\t\tvar numWithN = 0;\n\t\t\tfor (var i = 0; i < r.length; i++)\n\t\t\t{\n\t\t\t\tif (r[i][0] === '\\n')\n\t\t\t\t\tnumWithN++;\n\t\t\t}\n\n\t\t\treturn numWithN >= r.length / 2 ? '\\r\\n' : '\\r';\n\t\t}\n\n\t\tfunction tryParseFloat(val)\n\t\t{\n\t\t\tvar isNumber = FLOAT.test(val);\n\t\t\treturn isNumber ? parseFloat(val) : val;\n\t\t}\n\n\t\tfunction addError(type, code, msg, row)\n\t\t{\n\t\t\t_results.errors.push({\n\t\t\t\ttype: type,\n\t\t\t\tcode: code,\n\t\t\t\tmessage: msg,\n\t\t\t\trow: row\n\t\t\t});\n\t\t}\n\t}\n\n\n\n\n\n\t/** The core parser implements speedy and correct CSV parsing */\n\tfunction Parser(config)\n\t{\n\t\t// Unpack the config object\n\t\tconfig = config || {};\n\t\tvar delim = config.delimiter;\n\t\tvar newline = config.newline;\n\t\tvar comments = config.comments;\n\t\tvar step = config.step;\n\t\tvar preview = config.preview;\n\t\tvar fastMode = config.fastMode;\n\t\tvar quoteChar = config.quoteChar || '\"';\n\n\t\t// Delimiter must be valid\n\t\tif (typeof delim !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(delim) > -1)\n\t\t\tdelim = ',';\n\n\t\t// Comment character must be valid\n\t\tif (comments === delim)\n\t\t\tthrow 'Comment character same as delimiter';\n\t\telse if (comments === true)\n\t\t\tcomments = '#';\n\t\telse if (typeof comments !== 'string'\n\t\t\t|| Papa.BAD_DELIMITERS.indexOf(comments) > -1)\n\t\t\tcomments = false;\n\n\t\t// Newline must be valid: \\r, \\n, or \\r\\n\n\t\tif (newline != '\\n' && newline != '\\r' && newline != '\\r\\n')\n\t\t\tnewline = '\\n';\n\n\t\t// We're gonna need these at the Parser scope\n\t\tvar cursor = 0;\n\t\tvar aborted = false;\n\n\t\tthis.parse = function(input, baseIndex, ignoreLastRow)\n\t\t{\n\t\t\t// For some reason, in Chrome, this speeds things up (!?)\n\t\t\tif (typeof input !== 'string')\n\t\t\t\tthrow 'Input must be a string';\n\n\t\t\t// We don't need to compute some of these every time parse() is called,\n\t\t\t// but having them in a more local scope seems to perform better\n\t\t\tvar inputLen = input.length,\n\t\t\t\tdelimLen = delim.length,\n\t\t\t\tnewlineLen = newline.length,\n\t\t\t\tcommentsLen = comments.length;\n\t\t\tvar stepIsFunction = isFunction(step);\n\n\t\t\t// Establish starting state\n\t\t\tcursor = 0;\n\t\t\tvar data = [], errors = [], row = [], lastCursor = 0;\n\n\t\t\tif (!input)\n\t\t\t\treturn returnable();\n\n\t\t\tif (fastMode || (fastMode !== false && input.indexOf(quoteChar) === -1))\n\t\t\t{\n\t\t\t\tvar rows = input.split(newline);\n\t\t\t\tfor (var i = 0; i < rows.length; i++)\n\t\t\t\t{\n\t\t\t\t\tvar row = rows[i];\n\t\t\t\t\tcursor += row.length;\n\t\t\t\t\tif (i !== rows.length - 1)\n\t\t\t\t\t\tcursor += newline.length;\n\t\t\t\t\telse if (ignoreLastRow)\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tif (comments && row.substr(0, commentsLen) === comments)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = [];\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tpushRow(row.split(delim));\n\t\t\t\t\tif (preview && i >= preview)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata = data.slice(0, preview);\n\t\t\t\t\t\treturn returnable(true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\tvar nextDelim = input.indexOf(delim, cursor);\n\t\t\tvar nextNewline = input.indexOf(newline, cursor);\n\t\t\tvar quoteCharRegex = new RegExp(quoteChar+quoteChar, 'g');\n\n\t\t\t// Parser loop\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t\t// Field has opening quote\n\t\t\t\tif (input[cursor] === quoteChar)\n\t\t\t\t{\n\t\t\t\t\t// Start our search for the closing quote where the cursor is\n\t\t\t\t\tvar quoteSearch = cursor;\n\n\t\t\t\t\t// Skip the opening quote\n\t\t\t\t\tcursor++;\n\n\t\t\t\t\tfor (;;)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Find closing quote\n\t\t\t\t\t\tvar quoteSearch = input.indexOf(quoteChar, quoteSearch+1);\n\n\t\t\t\t\t\tif (quoteSearch === -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!ignoreLastRow) {\n\t\t\t\t\t\t\t\t// No closing quote... what a pity\n\t\t\t\t\t\t\t\terrors.push({\n\t\t\t\t\t\t\t\t\ttype: 'Quotes',\n\t\t\t\t\t\t\t\t\tcode: 'MissingQuotes',\n\t\t\t\t\t\t\t\t\tmessage: 'Quoted field unterminated',\n\t\t\t\t\t\t\t\t\trow: data.length,\t// row has yet to be inserted\n\t\t\t\t\t\t\t\t\tindex: cursor\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn finish();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (quoteSearch === inputLen-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Closing quote at EOF\n\t\t\t\t\t\t\tvar value = input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar);\n\t\t\t\t\t\t\treturn finish(value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If this quote is escaped, it's part of the data; skip it\n\t\t\t\t\t\tif (input[quoteSearch+1] === quoteChar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tquoteSearch++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (input[quoteSearch+1] === delim)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Closing quote followed by delimiter\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\tcursor = quoteSearch + 1 + delimLen;\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (input.substr(quoteSearch+1, newlineLen) === newline)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Closing quote followed by newline\n\t\t\t\t\t\t\trow.push(input.substring(cursor, quoteSearch).replace(quoteCharRegex, quoteChar));\n\t\t\t\t\t\t\tsaveRow(quoteSearch + 1 + newlineLen);\n\t\t\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\t// because we may have skipped the nextDelim in the quoted field\n\n\t\t\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Comment found at start of new line\n\t\t\t\tif (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments)\n\t\t\t\t{\n\t\t\t\t\tif (nextNewline === -1)\t// Comment ends at EOF\n\t\t\t\t\t\treturn returnable();\n\t\t\t\t\tcursor = nextNewline + newlineLen;\n\t\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Next delimiter comes before next newline, so we've reached end of field\n\t\t\t\tif (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1))\n\t\t\t\t{\n\t\t\t\t\trow.push(input.substring(cursor, nextDelim));\n\t\t\t\t\tcursor = nextDelim + delimLen;\n\t\t\t\t\tnextDelim = input.indexOf(delim, cursor);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// End of row\n\t\t\t\tif (nextNewline !== -1)\n\t\t\t\t{\n\t\t\t\t\trow.push(input.substring(cursor, nextNewline));\n\t\t\t\t\tsaveRow(nextNewline + newlineLen);\n\n\t\t\t\t\tif (stepIsFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\tdoStep();\n\t\t\t\t\t\tif (aborted)\n\t\t\t\t\t\t\treturn returnable();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (preview && data.length >= preview)\n\t\t\t\t\t\treturn returnable(true);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\n\t\t\treturn finish();\n\n\n\t\t\tfunction pushRow(row)\n\t\t\t{\n\t\t\t\tdata.push(row);\n\t\t\t\tlastCursor = cursor;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the remaining input from cursor to the end into\n\t\t\t * row, saves the row, calls step, and returns the results.\n\t\t\t */\n\t\t\tfunction finish(value)\n\t\t\t{\n\t\t\t\tif (ignoreLastRow)\n\t\t\t\t\treturn returnable();\n\t\t\t\tif (typeof value === 'undefined')\n\t\t\t\t\tvalue = input.substr(cursor);\n\t\t\t\trow.push(value);\n\t\t\t\tcursor = inputLen;\t// important in case parsing is paused\n\t\t\t\tpushRow(row);\n\t\t\t\tif (stepIsFunction)\n\t\t\t\t\tdoStep();\n\t\t\t\treturn returnable();\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Appends the current row to the results. It sets the cursor\n\t\t\t * to newCursor and finds the nextNewline. The caller should\n\t\t\t * take care to execute user's step function and check for\n\t\t\t * preview and end parsing if necessary.\n\t\t\t */\n\t\t\tfunction saveRow(newCursor)\n\t\t\t{\n\t\t\t\tcursor = newCursor;\n\t\t\t\tpushRow(row);\n\t\t\t\trow = [];\n\t\t\t\tnextNewline = input.indexOf(newline, cursor);\n\t\t\t}\n\n\t\t\t/** Returns an object with the results, errors, and meta. */\n\t\t\tfunction returnable(stopped)\n\t\t\t{\n\t\t\t\treturn {\n\t\t\t\t\tdata: data,\n\t\t\t\t\terrors: errors,\n\t\t\t\t\tmeta: {\n\t\t\t\t\t\tdelimiter: delim,\n\t\t\t\t\t\tlinebreak: newline,\n\t\t\t\t\t\taborted: aborted,\n\t\t\t\t\t\ttruncated: !!stopped,\n\t\t\t\t\t\tcursor: lastCursor + (baseIndex || 0)\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t/** Executes the user's step function and resets data & errors. */\n\t\t\tfunction doStep()\n\t\t\t{\n\t\t\t\tstep(returnable());\n\t\t\t\tdata = [], errors = [];\n\t\t\t}\n\t\t};\n\n\t\t/** Sets the abort flag */\n\t\tthis.abort = function()\n\t\t{\n\t\t\taborted = true;\n\t\t};\n\n\t\t/** Gets the cursor position */\n\t\tthis.getCharIndex = function()\n\t\t{\n\t\t\treturn cursor;\n\t\t};\n\t}\n\n\n\t// If you need to load Papa Parse asynchronously and you also need worker threads, hard-code\n\t// the script path here. See: https://github.com/mholt/PapaParse/issues/87#issuecomment-57885358\n\tfunction getScriptPath()\n\t{\n\t\tvar scripts = document.getElementsByTagName('script');\n\t\treturn scripts.length ? scripts[scripts.length - 1].src : '';\n\t}\n\n\tfunction newWorker()\n\t{\n\t\tif (!Papa.WORKERS_SUPPORTED)\n\t\t\treturn false;\n\t\tif (!LOADED_SYNC && Papa.SCRIPT_PATH === null)\n\t\t\tthrow new Error(\n\t\t\t\t'Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +\n\t\t\t\t'You need to set Papa.SCRIPT_PATH manually.'\n\t\t\t);\n\t\tvar workerUrl = Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH;\n\t\t// Append 'papaworker' to the search string to tell papaparse that this is our worker.\n\t\tworkerUrl += (workerUrl.indexOf('?') !== -1 ? '&' : '?') + 'papaworker';\n\t\tvar w = new global.Worker(workerUrl);\n\t\tw.onmessage = mainThreadReceivedMessage;\n\t\tw.id = workerIdCounter++;\n\t\tworkers[w.id] = w;\n\t\treturn w;\n\t}\n\n\t/** Callback when main thread receives a message */\n\tfunction mainThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\t\tvar worker = workers[msg.workerId];\n\t\tvar aborted = false;\n\n\t\tif (msg.error)\n\t\t\tworker.userError(msg.error, msg.file);\n\t\telse if (msg.results && msg.results.data)\n\t\t{\n\t\t\tvar abort = function() {\n\t\t\t\taborted = true;\n\t\t\t\tcompleteWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });\n\t\t\t};\n\n\t\t\tvar handle = {\n\t\t\t\tabort: abort,\n\t\t\t\tpause: notImplemented,\n\t\t\t\tresume: notImplemented\n\t\t\t};\n\n\t\t\tif (isFunction(worker.userStep))\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < msg.results.data.length; i++)\n\t\t\t\t{\n\t\t\t\t\tworker.userStep({\n\t\t\t\t\t\tdata: [msg.results.data[i]],\n\t\t\t\t\t\terrors: msg.results.errors,\n\t\t\t\t\t\tmeta: msg.results.meta\n\t\t\t\t\t}, handle);\n\t\t\t\t\tif (aborted)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdelete msg.results;\t// free memory ASAP\n\t\t\t}\n\t\t\telse if (isFunction(worker.userChunk))\n\t\t\t{\n\t\t\t\tworker.userChunk(msg.results, handle, msg.file);\n\t\t\t\tdelete msg.results;\n\t\t\t}\n\t\t}\n\n\t\tif (msg.finished && !aborted)\n\t\t\tcompleteWorker(msg.workerId, msg.results);\n\t}\n\n\tfunction completeWorker(workerId, results) {\n\t\tvar worker = workers[workerId];\n\t\tif (isFunction(worker.userComplete))\n\t\t\tworker.userComplete(results);\n\t\tworker.terminate();\n\t\tdelete workers[workerId];\n\t}\n\n\tfunction notImplemented() {\n\t\tthrow 'Not implemented.';\n\t}\n\n\t/** Callback when worker thread receives a message */\n\tfunction workerThreadReceivedMessage(e)\n\t{\n\t\tvar msg = e.data;\n\n\t\tif (typeof Papa.WORKER_ID === 'undefined' && msg)\n\t\t\tPapa.WORKER_ID = msg.workerId;\n\n\t\tif (typeof msg.input === 'string')\n\t\t{\n\t\t\tglobal.postMessage({\n\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\tresults: Papa.parse(msg.input, msg.config),\n\t\t\t\tfinished: true\n\t\t\t});\n\t\t}\n\t\telse if ((global.File && msg.input instanceof File) || msg.input instanceof Object)\t// thank you, Safari (see issue #106)\n\t\t{\n\t\t\tvar results = Papa.parse(msg.input, msg.config);\n\t\t\tif (results)\n\t\t\t\tglobal.postMessage({\n\t\t\t\t\tworkerId: Papa.WORKER_ID,\n\t\t\t\t\tresults: results,\n\t\t\t\t\tfinished: true\n\t\t\t\t});\n\t\t}\n\t}\n\n\t/** Makes a deep copy of an array or object (mostly) */\n\tfunction copy(obj)\n\t{\n\t\tif (typeof obj !== 'object')\n\t\t\treturn obj;\n\t\tvar cpy = obj instanceof Array ? [] : {};\n\t\tfor (var key in obj)\n\t\t\tcpy[key] = copy(obj[key]);\n\t\treturn cpy;\n\t}\n\n\tfunction bindFunction(f, self)\n\t{\n\t\treturn function() { f.apply(self, arguments); };\n\t}\n\n\tfunction isFunction(func)\n\t{\n\t\treturn typeof func === 'function';\n\t}\n\n\treturn Papa;\n}));\n","module.exports = { \"default\": require(\"core-js/library/fn/array/from\"), __esModule: true };","require('../../modules/es6.string.iterator');\nrequire('../../modules/es6.array.from');\nmodule.exports = require('../../modules/_core').Array.from;\n","'use strict';\nvar ctx = require('./_ctx');\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar toLength = require('./_to-length');\nvar createProperty = require('./_create-property');\nvar getIterFn = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n    var O = toObject(arrayLike);\n    var C = typeof this == 'function' ? this : Array;\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var index = 0;\n    var iterFn = getIterFn(O);\n    var length, result, step, iterator;\n    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for (result = new C(length); length > index; index++) {\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n","'use strict';\nvar $defineProperty = require('./_object-dp');\nvar createDesc = require('./_property-desc');\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n"],"sourceRoot":""}